[{"title":"同步获取宽带公网ip的一个思路","path":"/posts/2024/3FA817D7/","content":"家里的宽带是电信的。电信的宽带比联通或是移动的是贵一些，但有一个优点是可以比较简单的申请到公网ip。有了公网ip之后，我们就可以用来做一些有趣的事情，比如远程登录到家里的台式机，访问家里的黑群晖。 但需要注意的是，这个ip是不固定的，即重新拨号之后，地址将会变掉。虽然略有不方便的地方，但搭配上路由器的DDNS功能和端口转发功能，就可以使用域名来访问到这个地址下开通的服务。 最近一段时间，不知道什么原因，路由器的ddns注册功能总是异常，表现为域名注册失败。这下，在外面再也不能简单的连到家里的网络了。虽然可以通过公网ip来进行连接，但这建立在我记住了最新的ip而路由器没有重新拨号的前提下。 这几天，由于沉迷看芙莉莲，发生了几次兴冲冲想要打开emby server但却连不上的尴尬局面。也许是时候想办法解决这个问题了。首先我对ddns注册不上的问题毫无思路，我只能&#x3D;退而求其次，从同步获取最新的公网ip地址方向来解决。 我的整体思路是，使用python脚本的方式来进行实现： 脚本持续运行。 每隔1个小时执行一次获取ip的操作。 和上次获取的ip进行比较，如ip不同，则将新的ip发送到指令的邮箱。 部署方案采用docker镜像的方式，部署在nas中。 首先是如何获取到公网ip。从路由器的管理台倒是能够直接查看到，但想要程序获取的话，就需要处理登录、session等等相关的问题，略显麻烦，放弃。 在google的帮助下，找到了一个可以展示ip的web页面：https://2024.ip138.com。查看了之后，确认可以正确的展示公网ip。就选择你了。 获取ip的问题解决了之后，剩下的工作就十分简单了。在chatgpt的帮助下，十分钟不到就完成了脚本的编写。其中，main 函数是脚本主题逻辑。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293import osimport smtplibimport timefrom datetime import datetimefrom email.mime.text import MIMETextfrom email.header import Headerimport requestsfrom bs4 import BeautifulSoupdef get_public_ip(): &quot;&quot;&quot; 获取公网ip地址 :return: &quot;&quot;&quot; headers = &#123; &#x27;User-Agent&#x27;: &#x27;PostmanRuntime/7.26.8&#x27;, &#x27;Accept&#x27;: &#x27;*/*&#x27;, &#x27;Accept-Encoding&#x27;: &#x27;gzip,deflate,br&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27; &#125; get_ip_url = &#x27;https://2024.ip138.com&#x27; resp = requests.get(get_ip_url, headers=headers) html=resp.text bs = BeautifulSoup(html, &#x27;html.parser&#x27;) title = bs.find_all(&#x27;title&#x27;) if len(title) &gt; 0: text = title[0].text return text.split(&#x27;：&#x27;)[-1]def send_email(sender, password, receiver, content): &quot;&quot;&quot; 使用sender向receiver发送邮件 :param sender: 发送方 :param password: 发送方token :param receiver: 接收方 :param content: 内容 :return: &quot;&quot;&quot; if not content: print(&#x27;no content to send&#x27;) return subject = f&#x27;Today\\&#x27;s ip is &#123;content&#125;, and now is &#123;str(datetime.now())&#125;&#x27; message = MIMEText(content, &#x27;plain&#x27;, &#x27;utf-8&#x27;) message[&#x27;From&#x27;] = Header(sender, &#x27;utf-8&#x27;) message[&#x27;To&#x27;] = Header(receiver, &#x27;utf-8&#x27;) message[&#x27;Subject&#x27;] = Header(subject, &#x27;utf-8&#x27;) try: smtp_obj = smtplib.SMTP_SSL(&#x27;smtp.163.com&#x27;, 465) smtp_obj.login(sender, password) smtp_obj.sendmail(sender, receiver, message.as_string()) print(&#x27;send successfully.&#x27;) except smtplib.SMTPException as e: print(e) finally: smtp_obj.close()def main(): previous_ip = &#x27;&#x27; sender = os.getenv(&#x27;sender&#x27;) password = os.getenv(&#x27;password&#x27;) receiver = os.getenv(&#x27;receiver&#x27;) if not sender or not password or not receiver: print(&#x27;no environment variables&#x27;) return -1 while True: try: ip = get_public_ip() except Exception as e: print(e) else: if previous_ip != ip: previous_ip = ip try: send_email(sender, password, receiver, ip) except Exception as e: print(e) else: print(&#x27;no difference since last fetched.&#x27;) print(&#x27;now, sleep for 1 hours&#x27;) time.sleep(60 * 60)if __name__ == &#x27;__main__&#x27;: main() 前面的环节一切顺利，到了制作docker镜像的时候遇到了点麻烦。我需要选择一个包含python执行环境的docker镜像，但pull镜像的时候才发现，包含python运行环境的基础镜像都有7、8百兆之大。为了我这么一个小小的需求，这未免有些太过于劳师动众了。后面，灵机一动，想到了将脚本打包的方式。通过使用pyinstaller对脚本进行了打包。 使用pyinstaller对脚本进行打包的方式是： 1pyinstaller -F -p &quot;.venv/Lib/site-packages&quot; ../main.py 最终得到了一个80M作用的镜像。 1234567FROM ubuntu:20.04MAINTAINER maslkeENV TZ=Asia/ShanghaiCOPY spec/dist/main /rootWORKDIR /rootCMD [&quot;./main&quot;] 最后，在docker中创建容器的时候，设置好sender、receiver和password环境变量，即可正常启动运行了。需要注意的是，发送邮箱需要开启smtp服务。 至此，问题完美解决。","tags":["ip","docker","python"],"categories":["生活"]},{"title":"百度地图切片方案","path":"/posts/2023/DxCG4fhmmrfuHtslrDfwIQ/","content":"在使用arcgis js api 或是 openlayers 来进行百度地图切片加载的时候，由于百度地图采用的是私有、非标准的切片方案，不能像加载谷歌切片或是天地图切片一样，api原生支持、开箱即用，而是需要进行定制化的开发来实现切片的加载 定制化百度地图切片的加载策略，需要知道百度地图切片方案的切片起点(origin)、切片分辨率(resolutions)、切片范围(full extent)、切片正方向定义(x positive direction 、y positive direction)、切片尺寸等。百度切片方案的以上信息，都与标准web mercator切片方案有着差异。我们知道，标准web mercator切片方案的切片起点为切片范围的左上角（top,left)，切片范围为[-180,-85,180,85]范围，切片x正方向由left到right列号递增，切片y正方向由top到bottom行号递增，切片尺寸为[256,256]大小。那百度地图是怎样的呢？ 网上的信息带着这些问题，我查阅了很多资料。由于百度地图的使用者大多是中国人，因此网络上的资料也多是国人开发者写就。查了资料之后，不仅没有解决我的疑惑，反而使我的疑惑更加深了。汇总查找到的资料，百度地图切片方案: 起点是[-20037508.3427892,20037508.3427892] 切片的范围是[-20037508.3427892, -20037508.3427892, 20037508.3427892, 20037508.3427892]， 切片x正方向是由left到right，切片y正方向是从bottom到top。 带着以上配置，我编写了代码进行了测试。不过很遗憾，测试结果表明以上的信息有假有真，使用以上的配置，切片死活加载不出来，或者加载出来坐标也是错误的。由此，也可以看出中文文章（尤其是发布在csdn上的），大多是人云亦云，不求甚解。很多时候，明明是错误的信息，还是会被人抄来抄去。关于这点，就不发散了。 回到正题，那百度地图切片方案到底是如何定义的呢？下面我们就来试着推导一下。 推导的信息positive directions我们已经知道，百度地图的最小层级为3。在level&#x3D;3中，百度地市使用8 * 8张切片来表示整个切片范围。如下图所示。结合下图和组成下图的每一个小图片具体的行号和列号，可以确定“切片x正方向是由left到right，切片y正方向是从bottom到top”这句话是正确的。 可以发现，关于正方向的定义，百度切片方案和标准web mercator切片方案对于x正方向的定义相同，对于y正方向的定义是相反的。此处定义的不同，结合百度切片方案对于起点的定义，就会产生一个百度方案独有的地方，下面我们介绍了起点之后会着重说。 origin在以上的图片中，行号和列号为0的图片，如下所示。可以看到，图片最左端、上半部分为英国区域，为本初子午线穿过的地方。因此可以确定，百度地图切片方案的起点确确实实的是**[0,0]**，而不是[-20037508.3427892,20037508.3427892]。关于20037508.3427892这个数字是如何计算出来的，我们可以简单说一下： 标准web mercator切片方案下，整个切片范围为[180,85]经纬度范围，即整个经度范围。web mercator投影坐标使用的地球半径为6378137米，那么地球的周长为6378137 * Math.PI * 2米，均匀的分成2部分，即为20037508.342789244米。 说完了正方向和起点之后，细心的人应该已经发现了，在百度的方案中，起点不在地图的左上角，而是在中心，那么在百度切片方案中，存在着行号、列号为负数的清明的。在百度地图中，对于负数的行号和列号进行了特殊规定。简而言之，对于负数的行列号，使用M + 绝对值来进行表示。即，对于(-3,-4)这种行列号，在百度地图中使用(M3, M4)来进行表示。 full extent关于整个切图范围，我始终没有找到推导的方式。只能基于实际测试数据，得出一个经验值。此经验值是基于实际的代码加载测试得出的：**[-33554432, -33554432, 33554432, 33554432]**。如果此数值不正确，或是哪位有推导方式，还望告知。 虽然此范围，没有任何的科学推导过程，但好在可以经受住实际代码的测试。并且，使用百度在线坐标转换服务将此坐标进行转换，得到的结果如下图所示，也算是从侧面进行了验证吧。 12345678910// https://api.map.baidu.com/geoconv/v1/?coords=-33554432,33554432&amp;from=6&amp;to=5&#123; &quot;status&quot;: 0, &quot;result&quot;: [ &#123; &quot;x&quot;: -179.99999999851323, &quot;y&quot;: 89.40915130133585 &#125; ]&#125; 说句题外话，使用百度在线坐标转换服务，对坐标[-33554432, 33554432]进行连续的转换测试，先从投影坐标转换成经纬度，然后将经纬度再转换生成投影坐标，最后得到的结果与原始的坐标千差万别。不知道问题出在哪里。能想到的最可能的原因是，此坐标超过了接口适用范围。 resolution确定了切片范围之后，分辨率（分辨率的意义是：图片中每px像素所表示的实际距离的大小。）也就可以确定了。我们已知百度地图最小层级为3，在level&#x3D;3上，使用64张切片来表示整个切片范围。那么，level&#x3D;3时，分辨率为 1resolution = 33554432 * 2 / 256 / 8 随着level的递增，分辨率会成倍的递减。汇总可知百度切片的分辨率信息为 1[262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5] tilesize关于切片尺寸，由切片图片可以确定，为[256,256]大小。 切片加载汇总了以上信息之后，我们就可以定义百度切片地图tileinfo进行切片加载了。 tileinfo123456&#123;\tresolutions: [262144, 131072, 65536, 32768, 16384, 8192, 4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1, 0.5],\torigin: [0, 0],\ttileSize: [256, 256],\tfullExtent: [33554432, -33554432, 33554432, 33554432]&#125; 切片地址拼接前面说到，百度切片方案的y正方向和标准web mercator方案不同，因此在进行切片加载的时候需要自定义切片获取函数，进行行号和列号的转换。具体如何转换呢，查阅的资料大多都是按照如下的方式： 1234567891011121314151617const zoom = level - 1;const offsetX = parseInt(2 ** zoom, 10);const offsetY = offsetX - 1;let numX = col - offsetX;let numY = (-row) + offsetY;if (numX &lt; 0) &#123; numX = `M$&#123;-numX&#125;`;&#125;if (numY &lt; 0) &#123; numY = `M$&#123;-numY&#125;`;&#125;const url = getLayerUrl(this.layerType);return url .replaceAll(&#x27;&#123;server&#125;&#x27;, Math.floor(Math.random() * 10)) .replaceAll(&#x27;&#123;x&#125;&#x27;, numX) .replaceAll(&#x27;&#123;y&#125;&#x27;, numY) .replaceAll(&#x27;&#123;z&#125;&#x27;, level); 我翻遍了全网，只能看到此代码片段，却找不到任何对此代码的解释。不知道是不是太简单了，不值一提？还是大家都不求甚解，能解决问题即可，底层原因懒得深究（包括我）。 其实，以上的转换方式某种意义上是对的，但前提是建立在定义origin在[-33554432, 33554432]，即切片方案左上角的基础上。 以上关于行号和列号的转换方式，如果你感觉到困惑的画，配合下面这张图，就会让你豁然开朗了。 上图中，左侧为百度切片方案对x和y正方向的定义，右侧为标准web mercator切片方案对的定义。我们使用js api是使用右侧的定义对切片进行加载，要想获取到正确的百度切片地址，必须要进行转换。观察以上左右两侧的图片，可以发现，标准切片方案下获取到的x列号，需要减去全图范围一行中一半的切片个数，是百度切片方案下的列号。而标准切片方案下的y列号，被全图范围一行中一半切片个数减，再减去1，即使百度切片方案下的列号。即如下公式表示： 12x1 = x2 - offsety1 = offset - 1 - y2 其中，(x1,y1)为百度切片方案下的行列号，(x2,y2)为标准web mercator切片方案下的行列号，offset为当前层级下全图切片范围一行中切片个数的一半。x为列号，y为行号。如果得到的x1和y1为负数，还需要按照前面介绍的规则进行转换（添加M）。 回头再来看，上面的转换代码。为了查看的方便，在此处再贴一遍。 1234567891011const zoom = level - 1;const offsetX = parseInt(2 ** zoom, 10);const offsetY = offsetX - 1;let numX = col - offsetX;let numY = (-row) + offsetY;if (numX &lt; 0) &#123; numX = `M$&#123;-numX&#125;`;&#125;if (numY &lt; 0) &#123; numY = `M$&#123;-numY&#125;`;&#125; 在以上的代码中，level为当前的层级，此层级下一行总的切片个数为math.pow(2, level)个，一半还需要除以2，这种方式和先计算level-1，再进行乘方运算等价。因此，就有了上述代码。 前面说到，这段代码正确的前提是orign定义在切片方案的左上角。那么，如果origin定义在[0,0]的话，还可以实现正确加载吗？关于此问题，感兴趣的可以自行探索一番。答案当然是可以的，转换方式参见下图即可。 明确了以上信息之后，就可以正确的进行百度地图切片的加载了。使用以上的参数进行切片的加载，可以保证坐标精度十分精准。下图中，上方为百度坐标拾取页面，下方为自行加载页面，使用的坐标为(13267851.39994815, 3876775.155571565)。 PS关于tileinfo中origin的定义，arcgis js api和openlayers对此的定义不尽相同。 在openlayers中对origin的定义是 The tile grid origin, i.e. where the x and y axes meet ([z, 0, 0]). Tile coordinates increase left to right and downwards. If not specified, extent or origins must be provided. 而在arcgis js api中对origin的定义是 The tiling scheme origin. The upper left corner of the tiling scheme, in coordinates of the spatial reference of the source data. 即，openlayers对origin的定义是行列号坐标原点，而arcgis js api中对origin的定义是切片范围的左上角点。因此，在使用arcgis js api来加载百度切片的时候，只能将origin定义在[-33554432, 33554432]，并使用转换方式一。而在openlayers中，则两种方式都可以。","tags":["arcgis","tile-map","baidu","openlayers"],"categories":["gis"]},{"title":"多线程设计模式简介","path":"/posts/2022/9_NWv-WlILJ7IEIQgU8WTQ/","content":"Single Threaded Execution模式所谓Single Threaded Execution模式，意思是“单一线程执行”。该模式用于设置限制，以确保同一时间只能让一个线程执行处理。 Single Threaded Execution模式中，存在着一种SharedResource角色。SharedResource角色是会被多个线程同时访问的类，类会包含多个方法。但这些方法主要分为如下的两类： safeMethod：多个线程同时调用也不会发生问题的方法。 unsafeMethod：多个线程同时调用会发生问题，因此必须加以保护的方法。 safeMethod方法，无需特别关注，因为多个线程同时调用也不会发生问题。 unsafeMethod，在Single Threaded Execution模式中，保证了同一时刻只能被一个线程执行。常用的控制方法为使用synchronized关键字对方法加以修饰。 当SharedResource角色的内部状态会发生变化，并且需要确保安全性的时候，我们就可以使用Single Threaded Execution模式来加以确保。 如下述的Counter类，getValue方法即为safeMethod，而increase方法为unsafeMethod，因为value++操作为非原子操作，在多个线程的并发执行下会发生数据争用问题，导致获取到错误的值。我们可以使用synchronized关键字修饰increase方法，使其变为临界区，同一时刻只允许一个线程进入临界区。 1234567891011121314public class Counter &#123;\tprivate int value;\tpublic Counter(int initial) &#123; this.value = initial;\t&#125; public synchronized increase() &#123; this.value++;\t&#125;\tpublic int getValue() &#123; return this.value;\t&#125;&#125; 除使用synchronized关键字之外，还可以使用jdk中提供的ReentrantLock，在此不再赘述。 使用Singled Threaded Execution模式的时候，需要注意防范可能的死锁问题。当存在如下的条件时，就会发生死锁。 存在多个SharedResource。 线程在持有某个SharedResource的锁的同时，还等待获取其它的SharedResource的锁。 获取SharedResource角色的锁的顺序并不固定。 破坏以上的三个条件的任意一个，就可以避免死锁的发生。 将多个sharedResource整合成一个进行获取。将操作需要获取的锁的个数由多个优化为一个，破坏了上述条件的1和2。 等待获取SharedResource锁的时候加上超时机制。线程在持有某个SharedResource锁的同时，在等待获取其它的SharedResource的锁的时候加上一个超时条件。如在规定的时间内没有获取到需要的锁，则释放自己已经持有的锁。 固定多个SharedResource的获取顺序。在需要获取多个锁的时候，每次都按照相同的顺序来申请SharedResource的锁。 Immutable模式Immutable模式中存在着状态不会发生改变的类，即Immutable类。在访问这些类的实例时，由于其状态不会变化，无需进行线程同步处理，程序为无锁操作，将具有较好的性能。 如下述的Person类 1234567891011121314151617class final Person &#123;\tprivate final String name;\tprivate final Integer age;\tpublic Person(String name, Integer age) &#123; this.name = name; this.age = age;\t&#125;\tpublic String getName() &#123; return this.name;\t&#125;\tpublic Integer getAge()&#123; return this.age;&#125;&#125; 如有多个线程，同时访问Person类的实例，可以看作存在着SharedResource。由于Person类的实例的状态无法发生改变，因此并不需要使用Single Threaded Pattern来进行确保。 jdk中的Stirng类、即使用了Immutable模式。 Guarded Suspension模式Guarded Suspension模式，意思是“保护性暂停”模式。如果当前线程继续执行会发生问题的话，就先暂停当前线程的执行。 暂停了线程之后，什么时候再重新开始执行呢？当”某个条件”得到了满足之后就可以了。因此，Guarded Suspension模式也被称为多线程的if模式。 例如如下的类Requests类，其中包含了一个局部变量linkedlist和两个方法put和take，linkedlistput方法用于存储请求，put方法向linkedlist中提交请求，take方法从linkedlist中获取请求。不同的线程分别访问take方法和put方法，线程在调用take方法的时候，如果当前linkedlist为空，此时则应该暂停线程的执行，等待linkedlist非空再继续。此时，即可使用Guarded Suspension模式。 12345678910111213public class Requests &#123;\tprivate final LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();\tpublic synchronized take() throws InterruptedException &#123; while (linkedList.isEmpty()) &#123; wait(); &#125; return linkedList.pollFirst();\t&#125;\tpublic synchronized put(String request) throws InterruptedException &#123; linkedList.offerLast(request); notifyAll();\t&#125;&#125; 当线程A在调用get方法的时候，如当前linkedList为空，则线程A调用wait()，进入等待队列等待。当其它线程调用了notifyAll方法之后，线程A将会被从等待队列中唤醒，重新判断条件是否满足。 以上的Requests中，如果对内部存储的请求的容量有上限要求，那么在put方法中也应该像是在take方法中判断是否为空一样，加入对是否已满的判断。 1234567891011121314151617181920public class Requests &#123;\tprivate final LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); private final static Integer CAPACITY = 100; public synchronized String take() throws InterruptedException &#123; while (linkedList.isEmpty()) &#123; wait(); &#125; String request = linkedList.pollFirst(); notifyAll(); return request; &#125; public synchronized void put(String request) throws InterruptedException &#123; while (linkedList.size() == CAPACITY) &#123; wait(); &#125; linkedList.offerLast(request); notifyAll(); &#125;&#125; 因在Guarded Suspension模式的模板代码中，经常会出现wait方法，因此此模式也经常性的被称为Guarded wait模式。 Balking模式在上面的Guarded Suspension模式中，当守护条件没有满足的时候，线程将会陷入阻塞，等待守护条件得到满足。在某些情况下，当发现条件没有满足的时候，我们希望立即返回，而不需要等待。这种模式称为Balking模式。Balking，即为停步返回的意思。 Balking模式的特点即是不进行循环等待。若守护条件不成立，则立刻返回并进入下一个操作。 懒加载模式下的单例模式的实现，可以看作是Balking模式。 12345678910public class Singleton &#123; private static Singleton instance; public static synchronized Singleton getInstance() &#123; if (instance != null) &#123; return instance; &#125; instance = new Singleton(); return instance; &#125;&#125; 在Guarded Suspension模式中，当守护条件不满足的情况下，线程会一直等待直到条件满足。在Balking模式下，当守护条件不满足的情况下，线程直接满足。在一直等待和直接返回之间，则存在着中间地带：等待守护条件满足或等待时间超时。可以称这种模式为带有超时时间的Guarded Suspension模式。那么这种模式如何来实现呢？ 还是以上文例子中的Requests例子来描述。在下述的take方法中， 我们假定最长等待时间为60s，超过这个时间，直接返回null。 123456789101112131415161718public class Requests &#123;\tprivate final LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;(); private static final int TIME_OUT = 60 * 1000;\tpublic synchronized String take() throws InterruptedException &#123; long start = System.currentTimeMillis(); while (linkedList.isEmpty()) &#123; long now = System.currentTimeMillis(); long left = TIME_OUT - (now - start); if (left &lt;= 0) return null; wait(); &#125; return linkedList.pollFirst();\t&#125;\tpublic synchronized void put(String request) throws InterruptedException &#123; linkedList.offerLast(request); notifyAll();\t&#125;&#125; Producer-Consumer模式Producer-Consumer模式，即生产者-消费者模式。生产者-消费者模式在日常的开发中使用非常的广泛，java世界中使用非常广泛的线程池，其实质就是生产者-消费者模式的实现。还有我们经常使用的消费队列，如Kafka等，也是典型的生产者-消费者模式的应用。 使用Producer-Consumer模式的好处是： 生产者、消费者没有直接耦合，而是经过中间人，实现了解耦。单方面的崩溃不会带来连锁反应。 中间人的存在，消除了生产者生产消息和消费者消费消息之间速度的差异带来的问题。 在Producer-Consumer模式的实现中，经常会使用到Guarded Suspension模式。 一个典型的Producer-Consumer模式的实现如下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MessageStore &#123; private static final int CAPACITY_LIMIT = 1000; private LinkedList&lt;Request&gt; linkedList = new ArrayList&lt;&gt;(); public synchronized put(Request request) throws InterruptedException &#123; while (linkedList.size() &gt;= CAPACITY_LIMIT) &#123; wait(); &#125; linkedList.offerLast(request); notifyAll(); &#125; public synchronized take() throws InterruptedException &#123; while (linkedList.isEmpty()) &#123; wait(); &#125; Request request = linkedList.pollFirst(); notifyAll(); return request; &#125;&#125;pubic class Consumer &#123; private MessageStore messageStore; public Consumer(MessageStore store) &#123; this.messageStore = store; &#125; public void consume() &#123; try &#123; while (true) &#123; Request request = this.messageStore.take(); // process request &#125; &#125; catch (InterruptedException ex) &#123; logger.error(ex.getMessage(), ex); &#125; &#125;&#125;public class Producer &#123; private MessageStore messageStore; public Producer(MessageStore store) &#123; this.messageStore = store; &#125; public void produce() &#123; try &#123; while (true) &#123; Request request = new Request(); this.messageStore.put(request); &#125; &#125; catch (InterruptedException ex) &#123; logger.error(ex.getMessage(), ex); &#125; &#125;&#125;public class Request &#123; &#125; 对于Producer生产的消息，通过中间人，以什么样的顺序传递给Consumer，存在着不同的策略： 先生产先消费。实践上经常使用队列来进行实现。上述示例代码，使用就是此策略。 后生产先消费。实践上经常使用栈来进行实现。 优先级高的先消费。实践上经常使用优先级队列来实现。 在生产中，MessageStore的实现自然不会如此。在jdk中的juc包下，有着众多的支持多线程的集合实现。如ArrayBlockingQueue、LinkedBlockingQueue。多加使用juc下的多线程队列，可以让代码实现上更加简单、高效。如使用LinkedBlockingQueue改写上述的MessageStore。 12345678910111213public class MessageStore &#123; private static final int CAPACITY_LIMIT = 1000; private LinkedBlockingQueue&lt;Request&gt; linkedList = new LinkedBlockingQueue&lt;&gt;(CAPACITY_1000); public put(Request request) &#123; linkedList.put(request); &#125; public take() &#123; Request request = linkedList.take(); return request; &#125;&#125; Read-Write-Lock模式Read-Write-Lock模式，即读写锁模式。多线程并发读写的情况下，区分读操作和写操作，降低锁的粒度，使用不同的锁来进行控制。在执行读操作的时候，可以申请共享性的读锁，允许多个线程并发的读；在执行写操作的时候，需要申请独占性的写锁。在申请共享读锁的时候，应优先排他写锁的申请。 一个简单的ReadWriteLock的实现示例代码如下。 123456789101112131415161718192021222324252627282930public class ReadWriteLock &#123;\tprivate int readings = 0;\tprivate int writings = 0;\tprivate int waitings = 0;\tpublic synchronized void readLock() throws InterruptedException &#123; while (writings &gt; 0 || waitings &gt; 0) &#123; wait(); &#125; readings++;\t&#125; public synchronized void readUnlock() throws InterruptedException &#123; readings++; nofifyAll();\t&#125; public synchronized void writeLock() throws InterruptedException &#123; waitings++; while (readings &gt; 0 || writings &gt; 0) &#123; wait(); &#125; waitings--; writings++;\t&#125; public synchronized void writeUnlock() &#123; writings--; nofityAll(); &#125;&#125; 以上的代码仅为示例，更加准确、高效的ReadWriteLock实现，请学习参阅jdk中的juc包下的ReentrantReadWriteLock实现。 还有一种类似的模式称为Copy-on-Write模式，即写时复制模式。此种模式下，在多线程并发读写的情况下，读操作由于数据的状态不会发生变化，因此无需执行加锁操作，写操作需要申请锁。在临界区内，执行数据的复制，复制完成后，执行数据的替换。因此，此种模式适用于读多写少的场景。同时，由于在写操作的时候会复制整个数据，因此数据不能太大，否则数据的复制将会花费较多的时间和内存的占用。 jdk中的juc包下，存在着CopyOnWriteArrayList和CopyOnWriteArraySet两个写时复制容器。这两个容器的读取操作时无锁实现，因此读的性能很高。 Thread-Per-Message模式Thread-Per-Message模式，直译是指“每个消息一个线程”，即在消息到来时，为每个消息都单独创建一个线程来进行处理。 1234567public void handle(final Message message) &#123;\tnew Thread() &#123; public void run() &#123; // process message &#125; &#125;.start();&#125; 如上述代码，在handle函数中，每个消息都会被一个单独的Thread来进行处理。 此模式的好处是，消息调用线程和消息处理线程是相互独立的。调用线程无需等待消息处理完成，将消息处理委托给新创建的线程之后，就可以返回。这能显著提高响应性，降低延迟时间。很常用的应用场景包括GUI程序、web服务器程序。 此模式同时也存在着如下的特点： 一般情况下，无需线程处理的结果。如果需要等待线程处理的结果，可考虑使用Future模式。 消息处理的顺序，并不严格遵守消息到来的顺序。线程的执行顺序，和线程的创建顺序无关，由操作系统来进行调度。 消息到来说，都会创建新的线程。线程的创建需要一定的耗时。为了减少创建线程的时间，可以提前创建好线程，就是后面将要说到的Worker Thread模式。 消息过多时，创建的线程数存在过多，导致耗尽系统资源的风险。请衡量使用场景，必要时使用Worker Thread模式。 Worker Thread模式Worker Thread模式，即工作者线程模式。与上面的Thread-Per-Message相比，它们的不同点如下： Worker Thread模式中线程是提前创建好的，Thread-Per-Message模式中线程在消息到来时创建。 Worker Thread模式中线程和消息不是一一对应的，线程处理完消息之后，会等待下一个消息带来，线程会重复利用。Thread-Per-Message模式中，线程和消息一一对应，无法复用。 如下述的代码中，Handler类实例在接收到消息的时候，会将消息缓存起来。同时，在Handler类中开启了一定数量的线程，线程会循环的从缓存中读取消息，进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940public class Handler &#123; public static final int THREAD_COUNT = 100; private LinkedList&lt;Message&gt; list; WorkerThread[] threads = new WorkerThread[THREAD_COUNT]; public Handler() &#123; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threads = new WorkerThread(handler); &#125; list = new LinkedList&lt;&gt;(); &#125; public void handle(Message message) throws InterruptedException &#123; this.list.offerLast(message); notifyAll(); &#125; public synchronized Message getMessage() throws InterruptedException &#123; while (list.isEmpty()) &#123; wait(); &#125; return list.pollFirst(); &#125;&#125;public class WorkerThread implements Runnable &#123; private Handler handler; public WorkerThread(Handler handler) &#123; this.handler = handler; &#125; public void run() &#123; for(;;) &#123; Message message = this.handler.getMessage(); // process the message &#125; &#125;&#125; 可以看到，WorkerThread的数量越多，消息的并发处理能力越强。但是我们知道，操作系统中创建线程是存在开销的，增加线程的个数，就会带来更多的系统占用。同时，WorkerThread线程的数量超过了同时需要处理消息的数量，多余的WorkerThread也没有什么意义。 关于对Worker Thread模式中的WorkerThread，试着去思考如下的问题： WorkerThread线程的个数，需要创建多少个？ WorkerThread是在系统启动的时候就进行创建，还是在消息到来的时候再进行创建？ WorkerThread线程创建之后，就一直存活吗？能否在适当的时候，关闭某些空闲的线程？ WorkerThread线程可否随着消息的增多，而保持增多？随着消息的减少，而保持减少？ 对于Handler类中的消息缓存队列，也请去思考如下问题： 缓存队列的长度是无限的吗？持续向队列中提交消息，会发生什么？ 假如缓存队列长度是固定且有限的，那超过了队列缓存长度的消息，应该怎么处理？ 以上的思考，在jdk中的ThreadPoolExecutor中都有答案，请参阅学习。 Future模式前面在Thread-Per-Message模式中说到了，在此模式中无法获取到线程的执行结果。如想要获取到执行结果，则可以考虑使用Future模式。 Future模式，即在线程执行之后，不进行等待，而是先返回给调用者Future对象，调用者后续可以在合适的时候使用此Future对象来获取线程执行的结果。 12345678910111213141516171819202122232425public Future handle(final Message message) &#123; final Future future = new Future(); new Thread() &#123; public void run() &#123; // process message future.setData(&quot;Result&quot;); &#125; &#125;.start(); return future;&#125;public class Future &#123; private String data; public Future() &#123; &#125; public void setData(String data) &#123; this.data = data; &#125; public String get() &#123; return this.data; &#125;&#125; 如上述代码所示，在讲消息提交到handle函数之后，handle函数返回了一个future对象并且返回。在线程执行完成消息处理之后，会将线程执行的结果，通过调用future的setData方法，附加到future中。如想要获取到线程的执行结果，则可通过如下方式调用 1234while (future.get() == null) &#123;\twait();&#125;String data = future.get(); 在上述的示例代码中，只做了简单示范，future的get函数没有进行阻塞处理，即当线程没有执行完成之后，get操作也直接返回。因此，在客户端获取线程结果的调用中，需要使用Guarded Suspension模式去循环执行结果。也可以选择在get函数中进行阻塞，同步线程的处理结果，客户端调用则无需使用while循环处理。 在jdk的juc包中，提供了Future模式的一系列相关的类和接口，如Callable、Future、FutureTask等，请参阅相关资料学习。 ThreadLocal模式ThreadLocal模式，可以直译为线程本地存储模式。每一个线程都持有一份数据，数据在各个线程之间不进行共享，自然做到了数据的互不影响。 jdk中的ThreadLocal类即是此模式的有效利用。在ThreadLocal类中，定义了set方法和get方法。set用于向线程中添加关联数据。调用get方法，可以获取到与当前线程关联的数据。 ThreadLocal的实现，保证了在多个线程都持有ThreadLocal的实例的时候，在各个线程中调用实例的get方法，获取到的数据都是线程独有的。 12public void set(T value);public T get(); 如下述示例代码。ThreadLocal中存储了线程的名称，在执行append方法的时候，通过调用thread.get()将会获取到当前执行append操作的线程的名称。 12345678910111213141516171819202122232425262728293031323334public class LogAppender &#123; private ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public void append(PrintStream stream) &#123; stream.println(threadLocal.get() + &quot; print out&quot;); &#125; public void setThreadName(String name) &#123; this.threadLocal.set(name); &#125;&#125;public class LogThread extends Thread &#123; private LogAppender appender; private int index; private boolean initialized = false; LogThread(LogAppender appender, int index) &#123; this.appender = appender; this.index = index; &#125; public void run() &#123; if(!this.initialized) &#123; this.initialized = true; this.setName(&quot;Thread-&quot; + this.index); this.appender.setThreadName(this.getName()); &#125; this.appender.append(System.out); &#125;&#125; Two-Phase Termination模式Two-Phase Termination模式，即两阶段终止模式。不同于上面的那些模式，是关于如何创建线程来运行，Two-Phase Termination模式是关于如何优雅的终止线程的运行。确切一些的说，是关于如何在A线程中优雅的关闭B线程，不会让B线程突然暴毙，而是可以让B线程在关闭之前可以执行某些操作。 Thread类中的stop方法，可以用于关闭线程，但现在已经废弃，原因即是调用stop来关闭线程，只能让线程突然暴毙，但无法做到优雅。同时，处于sleep状态的线程，无法即时响应stop方法，会降低系统响应性。 Two-Phase Termination模式，顾名思义，分为两个阶段来进行。第一阶段是向想要关闭的线程发布关闭通知，第二阶段是线程响应通知执行关闭操作。 第一阶段，发布通知，可以概括为设置标志位和调用interrupt方法。 1234567891011121314151617181920212223242526272829303132public class WorkerThread extends Thread &#123;\tprivate volatile boolean shouldTerminate = false; public void setTerminate() &#123; this.shouldTerminate = true; interrupt(); &#125; public boolean getShouldTerminate() &#123; return this.shouldTerminate; &#125; public void run() &#123; try &#123; while (!getShouldTerminate()) &#123; doWork(); &#125; &#125; catch (InterruptedException ex) &#123; Thread.currentThread.interrupt(); &#125; finally &#123; doShutdown(); &#125; &#125; private void doShutDown() &#123; // process shut down &#125; private void doWork() &#123; // do work &#125;&#125; 需要注意的是上面interrupt方法的调用，处于sleep状态的线程将会转向runnable状态，从而可以响应操作。处于wait状态的线程，如果只进行了shouldTerminate标志位的设置，而不调用interrupt方法的话，线程也不会中等待队列中出来，所以也必须调用interrupt方法对线程下来“中断wait”的指示。 在“极客时间-java并发编程实战”中讲到：两阶段终止模式是一种应用很广泛的并发设计模式，在java预研中使用两阶段终止模式来优雅地终止线程，需要注意两个关键点：一个是仅检查终止标志是不够的，因为线程的状态可能处于休眠态；另一个是仅检查线程的中断状态也是不够的，因为我们依赖的第三方类库很可能没有正确处理中断异常“。 Active Object模式Active Object模式，即主动对象模式。在此处，主动对象时指本身具有线程的对象。主动对象模式可将调用者任务提交和任务执行分离，任务的执行在Active Object对象的线程中执行。Active Object可以从外部接收和处理异步任务，并且在合适的时机可以将任务处理的结果返回给调用者。 调用者在进行任务提交的时候，Active Object会将任务封装成统一的对象。如下述示例代码所示。 12345678910111213interface ActiveObject &#123; Future&lt;String&gt; process();&#125;public class ActiveObjectImpl implements ActiveObject &#123; private final ExecutorService service = Executors.newSingleThreadExecutor(); public Future&lt;String&gt; process() &#123; Future&lt;String&gt; future = service.submit(() -&gt; &quot;result...&quot;); return future; &#125;&#125;","tags":["多线程","设计模式"],"categories":["java","多线程"]},{"title":"麻将和牌算法简介","path":"/posts/2022/2E51C785/","content":"日常生活中，我有一个非常浪费时间的爱好，那就是麻将。虽然没有经过系统的学习和训练，水平非常一般，但我还是乐此不疲。作为一个程序员，在打麻将之余，也总会不自觉地去思考麻将的和牌算法应该怎么去实现。今天就来谈一下我对这个问题的一些粗略想法。 麻将介绍麻将，想必大家都不陌生，它是由饼子、万子、索子、字牌、三元牌组成。其中，饼子、万子、索子分别有数字1-9的9种牌，每个数字4张，共计108张。字牌由东、南、西、北组成，三元牌由白、发、中组成，每个也是4张，共计28张。在有些地方的玩法中，只包括饼子、万子、索子，会去掉字牌和三元牌。我们此处的介绍中，以现在比较流行的日麻规则为基础。日麻规则，包括了上述全部的136张牌。 借由国内知名日麻平台“雀魂”的一张图，来看一下所有的麻将牌种类。需要说明的是，除了上面说到的普通的牌之外，下图中还有额外的一张红5索、红5万、红5饼。这是日麻中的赤dora（宝牌），一张赤dora在和牌的时候就可以将手牌的价值提高一番。 麻将的和牌，是需要做成4面子+1雀头的牌型。雀头，由2张完全相同的牌组成，比如2张1饼、2张9万。面子，是顺子和刻子的统称。顺子，即3张连续的牌组合，比如1饼2饼3饼或是3万4万5万。刻子，是3张完全相同的牌组合，比如3张1饼或是3张东风。当然了，刻子也可以是4张相同的牌组合，比如4张5索，叫做杠子，可以认为是刻子的加强版。顺子只能由饼子、万子、索子组成，不能由字牌和三元牌组成，因为我们认为不同的字牌和三元牌之间没有连续性。 除了以上的规则之外，通常来说麻将还有两种额外的和牌规则。 一种是七对子，即最后手里的牌型可以组合成7个不同的对子。 还有一种叫做国士无双（国内通常叫做十三幺），即手里聚齐了1万9万1饼9饼1索9索东南西北白发中，再加上另外的以上提到的任意一张牌。 和牌算法基于以上的规则，我们来构思判断是否可以和牌的算法。 为了下面行文的方面，我们将饼子称为p，万子称为m，索子成为s，则5饼则可以表示为5p，3万可以表示为3m，1索可以表示为1s，以此类推。字牌稍微有些麻烦，我们称之为z，按照东南西北白发中的顺序分别编号为1-7，即1z表示东风，7z表示中。其中，上文中提到的赤dora则分别别是为0p，0m和0s。 为了更好的判断顺子、刻子、雀头，我们可以将基于以上表示规则的麻将牌转化为数字表示。具体的规则如下： 万子表示为1-9. 饼子表示为11-19 索子表示为21-29 东西南北白发中按照顺序分别表示为31、33、35、37、39、41、43. 赤dora按照万子、饼子、索子，分别表示为5、15和25. 按照以上的规则来设计，保证了同种麻将牌之间数字是连续的，而不同种麻将牌之间则存在着数字的间隔，可以简化判断三张麻将牌是否为顺子的逻辑。 对于一手麻将牌，在进行是否和牌判断之前，先按照上述规则转换为数字表示，并进行排序。以下的说明，都是基于这个排过序的数字数组。 在上面的基本介绍中，我们说明了3种和牌牌型。七对子和国士无双判断逻辑十分简单，我们此处重点来说明普通和牌型，即4面子+1雀头型。 需要说明的是，本文种的算法默认不存在吃、碰、杠行为，手牌保持13 + 1张的状态。但本文描述的算法稍加改动即可适配，因为吃、碰等副露行为会使得手牌减少，算法调整为(4 - x)面子+1雀头型即可，x为副露次数。 以下为对算法流程的描述： 判断数组中是否包含对子，即两张一样的牌。如果没有，不可能和牌。有，则记录下来。 对步骤1中统计出的对子，从当前手牌中标记手牌使用情况，并分别执行以下逻辑： 2.1 如当前未使用的手牌剩余为0，则返回和牌成功 2.2 如当前剩余未使用手牌中的第1张手牌无法组成一组顺子或刻子，则执行步骤2.4。 2.3 当前剩余未使用手牌中的第1张手牌，验证是否包含顺子。如包含顺子，标记手牌使用状态，然后重复执行2.1-2.4。 2.4 将步骤2.3中标记已使用的顺子重新标记未未使用，判断未剩余手牌中的第1张是否可组成刻子，如不包含，则和牌失败，还原手牌状态，返回到步骤2中执行。如可组成，从手牌中将此刻子标记为已使用，然后重复执行2.1-2.4。 和牌成功，将在步骤2中返回成功。流程执行到步骤3，返回和牌失败。 算法实现基于以上的算法流程，我们有如下的算法实现。为了编程上的方便，我们没有使用额外的数据结构来保存当前手牌的使用状态，而是简单执行了手牌的复制，并从中去除了已使用的手牌。 12345678910111213141516171819/** * win or not ? */function canWin(majs, maj) &#123; if (double7(majs) || all19(majs)) return true; const doubles = pickDouble(majs); if (doubles.length === 0) &#123; return false; &#125; for (let inx in doubles) &#123; const copy = majs.slice(0, majs.length); copy.splice(doubles[inx], 2); if (allTriple(copy)) &#123; return true; &#125; &#125; return false;&#125; 其中，double7函数判断是否为7对子和牌，all19为判断是否为国士无双和牌。实现分别如下 1234567891011121314151617181920212223242526272829303132333435363738/** * 七对子 * @param majs * @returns &#123;boolean&#125; */function double7(majs) &#123; const mapper = &#123;&#125;; for (let inx in majs) &#123; let val = majs[inx]; if (mapper.hasOwnProperty(val)) &#123; mapper[val] = mapper[val] + 1; &#125; else &#123; mapper[val] = 1; &#125; &#125; for (let key in mapper) &#123; if (mapper[key] !== 2) return false; &#125; return true;&#125;/** * 国士无双 * 打表实现 * @param majs */function all19(majs) &#123; const str = majs.toString(); const array = [1, 9, 11, 19, 21, 29, 31, 33, 35, 37, 39, 41, 43]; for (let inx = 0; inx &lt; 13; inx++) &#123; array.splice(inx, 0, array[inx]); if (array.toString() === str) &#123; return true; &#125; array.splice(inx, 1); &#125; return false;&#125; pickDouble函数为从手牌中统计出已有的对子。编程方便的考虑，此处记录的是对子起始的手牌序号，方便后面从手牌中删除此对子。 12345678910111213function pickDouble(majs) &#123; const indexes = []; let inx = 0, length = majs.length; while (inx &lt; length - 1) &#123; if (majs[inx] === majs[inx + 1]) &#123; indexes.push(inx); inx = inx + 2; &#125; else &#123; inx = inx + 1; &#125; &#125; return indexes;&#125; allTriple函数为逻辑的核心部分，作用在于判断剩下的手牌是否可完整组合成为面子牌型。 12345678910111213141516171819202122232425262728function allTriple(hands) &#123; if (hands.length === 0) &#123; return true; &#125; if (hands.length &lt; 3) &#123; return false; &#125; const val = hands[0]; let copy; if (hands[1] === val &amp;&amp; hands[2] === val) &#123; copy = hands.slice(0, hands.length); copy.splice(0, 3); const ret = allTriple(copy); if (ret) return true; &#125; if (hands.indexOf(val + 1) &gt; 0 &amp;&amp; hands.indexOf(val + 2) &gt; 0) &#123; let inx1 = hands.indexOf(val + 1); let inx2 = hands.indexOf(val + 2); copy = hands.slice(0, hands.length); copy.splice(0, 1); copy.splice(inx1 - 1, 1); copy.splice(inx2 - 2, 1); return allTriple(copy); &#125; return false;&#125;","tags":["麻将","算法"],"categories":["麻将","算法"]},{"title":"切片地图元信息配置说明","path":"/posts/2020/43467A63/","content":"在使用openlayers等javascript库来加载互联网在线地图或是geoserver等发布的切片地图的时候，经常需要对地图服务的相关元数据进行配置，如size、origin、dpi、lods等。本文将对以上配置项进行详细的说明，并以天地图在线地图服务为例配合讲解。 配置项sizesize即是切片地图每一个图片的大小，一般表示形式为数组形式，即[width, height]。当前阶段，常用的切片大小为[256, 256]，即每一个图片的大小为256 * 256，单位为px。 originorigin为切片计算的起点，用于确定在每一个比例尺下，行列号为(0,0)的切片的位置。origin通常使用一组数字来表示，分别表示x和y坐标。具体来说，origin所表示的位置，为行列号为(0,0)的切片的左上角所表示的位置。 dpidpi，它表示的意义是图片上每英寸长度内的像素的个数。常用的切片方案中，dpi为96，即每英寸长度内的像素的个数为96个（每英寸中像素为96px）。切图dpi也可自行定义，比如在某些版本的geoserver（geowebcache）服务器下，切图dpi为90。在使用arcgis server发布切片地图服务的过程中，也可自行更改dpi参数，默认情况下arcgis server切片的dpi为96。 高德地图切片dpi不唯一，分两个阶段。在1-9层级，dpi为44.38498293515359。在10-18层级，dpi为96.04726735598229。（此处描述有误，详情见文末说明） 天地图、谷歌地图的dpi为96.04726735598229。 百度地图的切片dpi为72.00885935769656。 以上dpi数字的计算方法是： 获取对应切片，查看图片的长和宽（以cm为单位），计为width。将cm转换为对应的英寸，即为width &#x2F; 2.54 根据dpi定义，计算dpi为 256 &#x2F; (width &#x2F; 2.54)。 lodslods为切片地图的重要参数，相对来说复杂一些。不同的切片地图，对应的lods参数也往往不同。lods的形式通常为数组形式，每一个数组项都表示了一个lod，lod中包含了level、resolution、scale等信息。 123456789101112[\t&#123; &quot;level&quot;: 16, &quot;resolution&quot;: 2.38865713397468, &quot;scale&quot;: 9027.977411 &#125;, &#123; &quot;level&quot;: 17, &quot;resolution&quot;: 1.19432856685505, &quot;scale&quot;: 4513.988705 &#125;] levellevel即为切片方案的层级，用数字表示，反应到地图上即表示的是地图的zoom信息，也可以称之为缩放级别。具体数字为0或是1，并不重要，可以自行定义。 resolutionresolution表示的为切片的分辨率，意义为图上1px的距离表示实际距离的多少。resolution的作用为确定当前点位置所在的切片的行列号。大致的计算的方法如下： 计算出当前点位置和origin点位置的x和y的差值，表示了两点之间的实际距离。已知origin点所在的切片的行列号为(0,0)。 使用两点之间的实际距离，去除当前的resolution，可以得出当前点和origin点之间的像素距离。 计算出了两点之间的像素距离，并且已知了每一个切片的大小（比如为256px * 256px），则可以计算出两者之间的切片的个数，即大体可得当前点和origin点在水平方向和竖直方向上存在着多少个切片，即得出行号和列号。 以上，说明了resolution参数的作用。下面，来说明如何来计算resolution的值。 以天地图的web mercator投影（wkid:3857）的在线切片地图为例，其在线地图切片的第0个层级的resolution信息如下： 12345&#123; &quot;level&quot;: 0, &quot;resolution&quot;: 156543.033928, &quot;scale&quot;: 591657527.591555&#125; 那以上的resolution是如何计算出来的呢？ 计算过程如下：已知web mercator投影的地理坐标系为WGS84坐标系，参考椭球的长半轴长度为6378137米，那么此椭球的赤道周长为6378137 * 2 * math.pi &#x3D; 40075016.68557849米。天地图的切图方案中，在0层级，会使用一张256 * 256的图片来表示整个世界范围。根据resolution的定义，在第0层级中，resolution则可以计算得出40075016.68557849 &#x2F; 256 &#x3D; 156543.03392804097，即是上面写出的数字。 上面已经说到，天地图的切图方案中，第0层级，使用一张256 * 256 大小的图片来表示整个世界范围。在下一个层级，即第1层级中，在水平方向和竖直方向，分别会一分为二，即使用共计4张256 * 256的图片来表示整个世界范围。由于同一方向上，图片一分为2，则可知resolution变为上一层级的二分之一，即78271.51696402048。往下的层级中，以此类推。 （实际上，当前的天地图切图方案中，第0层级中并没有真正的进行切图，访问第0层级的切片地址，将返回一个空白图片。） 说完了resolution之后，再回到上面提到的origin。回顾一下，origin是指切图方案中计算切片序号的起始点。起始点origin在一定程度上可以自行定义，只要定义的origin可以满足切图的需要。web mercator投影的天地图的切图方案origin定义为[-20037508.342787, 20037508.342787]，整个的切图范围为[-20037508.342787, -20037508.342787,20037508.342787, 20037508.342787]。在以上说明的基础上，可以给出此origin的计算方法。 xxxxxxxxxx private static void decode(Line line, String part, BiConsumer&lt;Point, Double&gt; consumer) { List items &#x3D; extract(part); int factor &#x3D; Integer.parseInt(items.get(0), 32); int difference &#x3D; 0; int inx &#x3D; 0; for (int i &#x3D; 1; i &lt; items.size(); i++) { int value &#x3D; Integer.parseInt(items.get(i), 32); difference +&#x3D; value; consumer.accept(line.getPoints()[inx++], difference * 1.0 &#x2F; factor); } }java 如下图所示，天地图的第0层级中，四张切片拼接之后，表示了整个的世界范围（从图上可以看出来，web mercator投影中，在高纬度地区，面积和形状的变形都相当之大，特别明显的就是北极附近的格陵兰岛。这也是为什么不推荐在web mercator投影下，计算大面积地物的面积。实践证明，对于省市行政区的面积计算，在web mercator投影下的面积计算，确定不具备现实意义）。 图片上的序号为切片的行号和列号，它们的url地址分别为，感兴趣的可以自行加载验证。 https://t0.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=w&amp;FORMAT=tiles&amp;TILECOL=0&amp;TILEROW=0&amp;TILEMATRIX=1&amp;tk=cd7427b91c597d6e859908210e8cb5ed https://t0.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=w&amp;FORMAT=tiles&amp;TILECOL=1&amp;TILEROW=0&amp;TILEMATRIX=1&amp;tk=cd7427b91c597d6e859908210e8cb5ed https://t0.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=w&amp;FORMAT=tiles&amp;TILECOL=0&amp;TILEROW=1&amp;TILEMATRIX=1&amp;tk=cd7427b91c597d6e859908210e8cb5ed https://t0.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=w&amp;FORMAT=tiles&amp;TILECOL=1&amp;TILEROW=1&amp;TILEMATRIX=1&amp;tk=cd7427b91c597d6e859908210e8cb5ed 如上所示，为天地图第2层级的16张切片拼接之后的展示效果，具体的切片地址就不再一一给出，从上述给出的地址中可以简单的推出。 天地图在线地图与谷歌在线地图服务、高德在线地图服务一个显著的区别是，它除了提供web mercator投影的切片方案之外，还额外提供了wgs84坐标系的切片方案。这两种方案的最大差异是，origin和lods信息都不一致。根据上面所讲的计算方案，可以得出在wgs坐标系下的切片方案，其origin为[-180, 90]，整个切图范围在[-180,-90,180,90]，在第0层级下的resolution为180 * 2 &#x2F; 256 &#x3D; 1.40625，其余层级的resolution可以依次计算。 在地理坐标系下，切图url地址如下所示。替换TILEMATRIX、TILEROW、TILECOL参数后，即可获取任一需要的切片。 https://t0.tianditu.gov.cn/vec_c/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=c&amp;FORMAT=tiles&amp;TILECOL=0&amp;TILEROW=0&amp;TILEMATRIX=1&amp;tk=cd7427b91c597d6e859908210e8cb5ed。 地理坐标系下，第1层级的切片拼接后，展示如下。由于地理坐标系下的切图整个范围为[-180,-90,180,90]。水平方向上的长度是竖直方向上的2倍，导致水平方向上需要的切片数量也将是竖直方向上切片数量的2倍。因此，(0,0)和(0,1)两张图片即可表示整个世界范围，(1,0)和(1,1)两张图片为空白图片。 第2层级的切图拼接效果如下所示。 scalescale是指图上距离与实际距离的比值（表示形式为1:M，图上1cm，表示真实的距离为Mcm），表示的含义是放缩的尺度。scale与具体的切图方案无关，而是切图方案确定之后的衍生信息。根据以上的dpi、resolution等信息，可以计算出在给定resolution的情况下，比例尺的大小。 scale的计算可以从以下的推导得出： 已知resolution的概念为1px表示实际距离的多少（在投影坐标系下，以米为单位；在地理坐标系下，以度为单位），dpi的概念为1英寸中包含多少个像素（px）。 从1可知，1英寸中包含的实际距离为dpi * resolution。 1英寸等价于2.54cm。从2可知，图上距离的0.0254米，表示了真实距离的dpi * resolution 米，则可知比例尺的大小为 dpi * resolution &#x2F; 0.0254。 再看一下，天地图的web mercator投影（wkid:3857）的在线切片地图，其在线地图切片的第0个层级的resolution信息如下： 12345&#123; &quot;level&quot;: 0, &quot;resolution&quot;: 156543.033928, &quot;scale&quot;: 591657527.591555&#125; 根据我们以上的推导，计算出的比例尺应该为 96 * 156543.033928 &#x2F; 0.0254 &#x3D; 591658710.9089763。结果与以上的比例尺数字相符。 以上，我们验证了在web mercator投影下的resolution和scale之间的关系，那这个计算方法在wgs84坐标下是否也成立呢？ 结果是显然的，这个计算公式并不成立。原因也很明显，resolution的概念是和具体坐标系相关，在投影坐标系下，表示1px表示实际距离多少米，而在地理坐标系下，表示1px表示实际距离多少度，而scale的概念则一直是图上1cm表示实际距离多少cm。这之间就出现了一个单位上的不一致。弥补的方法也非常的简单，通过dpi * resolution &#x2F; 0.0254，计算出的结果是图上1cm表示实际坐标单位。在投影坐标系的情况下，实际坐标单位为米，结果满足比例尺的定义，不需要再行计算。在地理坐标系的情况下，实际坐标单位为度，将此结果再乘以一个mpu（mpu &#x3D; meter per unit，每一坐标单位表示多少米）即可。 对于投影坐标系，可以认为mpu为1。对于地理坐标系来说，可以认为mpu为赤道的周长 &#x2F; 360。 先给出再wgs84坐标系下的某个lod定义，如下。 12345&#123; &quot;resolution&quot;: 0.703125, &quot;scale&quot;: 2.958293554545656E8&#125; 通过我们上述的说明，计算scale &#x3D; 0.703125 * 96 &#x2F; 0.0254 * (math.pi * 2 * 6378137) &#x2F; 360 &#x3D; 295829355.45456564。和上述给出的scale数字相比，验证了计算方法的正确。 以上，即对切片地图相关的配置信息、用途，以及如何对这些配置信息进行计算给出了详细的说明。具体的数字无需记忆。从定义入手，可以简单的计算得出。 常见地图切片方案总结天地图天地图的相关信息，在上文中已进行了详尽说明。此处为了使用上的方便，给出总结性信息。 天地图切图方案的最小层级为1级，最大层级为18级。 其web mercator投影的切片方案，切片地址格式为https://t0.tianditu.gov.cn/vec_w/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=w&amp;FORMAT=tiles&amp;TILECOL={x}&amp;TILEROW={y}&amp;TILEMATRIX={level}&amp;tk=cd7427b91c597d6e859908210e8cb5ed，其中TILEMATRIX为切片层级，TILEROW为切片行号，TILECOL为切片列号，第1级的resolution为78271.5169639999。 其wgs84地理坐标的切片方案，切片地址格式为https://t0.tianditu.gov.cn/vec_c/wmts?SERVICE=WMTS&amp;REQUEST=GetTile&amp;VERSION=1.0.0&amp;LAYER=vec&amp;STYLE=default&amp;TILEMATRIXSET=c&amp;FORMAT=tiles&amp;TILECOL={x}&amp;TILEROW={y}&amp;TILEMATRIX={level}&amp;tk=cd7427b91c597d6e859908210e8cb5ed，其中TILEMATRIX为切片层级，TILEROW为切片行号，TILECOL为切片列号，第1级的resolution为0.703125。 web mercator投影切图方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; dpi: 96, size: [256, 256], origin: [-20037508.342787, 20037508.342787], fullExtent: [-20037508.342787, -20037508.342787, 20037508.342787, 20037508.342787] lods: [&#123; &quot;level&quot;: 0, &quot;resolution&quot;: 156543.033928, &quot;scale&quot;: 591657527.591555 &#125;, &#123; &quot;level&quot;: 1, &quot;resolution&quot;: 78271.5169639999, &quot;scale&quot;: 295828763.795777 &#125;, &#123; &quot;level&quot;: 2, &quot;resolution&quot;: 39135.7584820001, &quot;scale&quot;: 147914381.897889 &#125;, &#123; &quot;level&quot;: 3, &quot;resolution&quot;: 19567.8792409999, &quot;scale&quot;: 73957190.948944 &#125;, &#123; &quot;level&quot;: 4, &quot;resolution&quot;: 9783.93962049996, &quot;scale&quot;: 36978595.474472 &#125;, &#123; &quot;level&quot;: 5, &quot;resolution&quot;: 4891.96981024998, &quot;scale&quot;: 18489297.737236 &#125;, &#123; &quot;level&quot;: 6, &quot;resolution&quot;: 2445.98490512499, &quot;scale&quot;: 9244648.868618 &#125;, &#123; &quot;level&quot;: 7, &quot;resolution&quot;: 1222.99245256249, &quot;scale&quot;: 4622324.434309 &#125;, &#123; &quot;level&quot;: 8, &quot;resolution&quot;: 611.49622628138, &quot;scale&quot;: 2311162.217155 &#125;, &#123; &quot;level&quot;: 9, &quot;resolution&quot;: 305.748113140558, &quot;scale&quot;: 1155581.108577 &#125;, &#123; &quot;level&quot;: 10, &quot;resolution&quot;: 152.874056570411, &quot;scale&quot;: 577790.554289 &#125;, &#123; &quot;level&quot;: 11, &quot;resolution&quot;: 76.4370282850732, &quot;scale&quot;: 288895.277144 &#125;, &#123; &quot;level&quot;: 12, &quot;resolution&quot;: 38.2185141425366, &quot;scale&quot;: 144447.638572 &#125;, &#123; &quot;level&quot;: 13, &quot;resolution&quot;: 19.1092570712683, &quot;scale&quot;: 72223.819286 &#125;, &#123; &quot;level&quot;: 14, &quot;resolution&quot;: 9.55462853563415, &quot;scale&quot;: 36111.909643 &#125;, &#123; &quot;level&quot;: 15, &quot;resolution&quot;: 4.77731426794937, &quot;scale&quot;: 18055.954822 &#125;, &#123; &quot;level&quot;: 16, &quot;resolution&quot;: 2.38865713397468, &quot;scale&quot;: 9027.977411 &#125;, &#123; &quot;level&quot;: 17, &quot;resolution&quot;: 1.19432856685505, &quot;scale&quot;: 4513.988705 &#125;, &#123; &quot;level&quot;: 18, &quot;resolution&quot;: 0.597164283559817, &quot;scale&quot;: 2256.998866688275 &#125;]&#125; wgs84地理坐标系切图方案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; size: [256, 256], dpi: 96, origin: [-180, 90], fullExtent: [-180, -90, 180, 90], lods: [&#123; &quot;level&quot;: 0, &quot;resolution&quot;: 1.40625, &quot;scale&quot;: 5.916587109091312E8 &#125;, &#123; &quot;level&quot;: 1, &quot;resolution&quot;: 0.703125, &quot;scale&quot;: 2.958293554545656E8 &#125;, &#123; &quot;level&quot;: 2, &quot;resolution&quot;: 0.351563, &quot;scale&quot;: 1.479146777272828E8 &#125;, &#123; &quot;level&quot;: 3, &quot;resolution&quot;: 0.175781, &quot;scale&quot;: 7.39573388636414E7 &#125;, &#123; &quot;level&quot;: 4, &quot;resolution&quot;: 0.0878906, &quot;scale&quot;: 3.69786694318207E7 &#125;, &#123; &quot;level&quot;: 5, &quot;resolution&quot;: 0.0439453, &quot;scale&quot;: 1.848933471591035E7 &#125;, &#123; &quot;level&quot;: 6, &quot;resolution&quot;: 0.0219727, &quot;scale&quot;: 9244667.357955175 &#125;, &#123; &quot;level&quot;: 7, &quot;resolution&quot;: 0.0109863, &quot;scale&quot;: 4622333.678977588 &#125;, &#123; &quot;level&quot;: 8, &quot;resolution&quot;: 0.00549316, &quot;scale&quot;: 2311166.839488794 &#125;, &#123; &quot;level&quot;: 9, &quot;resolution&quot;: 0.00274658, &quot;scale&quot;: 1155583.419744397 &#125;, &#123; &quot;level&quot;: 10, &quot;resolution&quot;: 0.00137329, &quot;scale&quot;: 577791.7098721985 &#125;, &#123; &quot;level&quot;: 11, &quot;resolution&quot;: 0.000686646, &quot;scale&quot;: 288895.85493609926 &#125;, &#123; &quot;level&quot;: 12, &quot;resolution&quot;: 0.000343323, &quot;scale&quot;: 144447.92746804963 &#125;, &#123; &quot;level&quot;: 13, &quot;resolution&quot;: 0.000171661, &quot;scale&quot;: 72223.96373402482 &#125;, &#123; &quot;level&quot;: 14, &quot;resolution&quot;: 8.58307e-005, &quot;scale&quot;: 36111.98186701241 &#125;, &#123; &quot;level&quot;: 15, &quot;resolution&quot;: 4.29153e-005, &quot;scale&quot;: 18055.990933506204 &#125;, &#123; &quot;level&quot;: 16, &quot;resolution&quot;: 2.14577e-005, &quot;scale&quot;: 9027.995466753102 &#125;, &#123; &quot;level&quot;: 17, &quot;resolution&quot;: 1.07289e-005, &quot;scale&quot;: 4513.997733376551 &#125;, &#123; &quot;level&quot;: 18, &quot;resolution&quot;: 5.36445e-006, &quot;scale&quot;: 2256.994353 &#125;]&#125; 高德地图高德地图的切片方案和天地图的切片方案完全一致，包括dpi、lods、size等。 最小层级为1，最大层级为18， 第1层级的resolution为78271.5169639999。高德在线地图只有web mercator投影的切片方案，其lods定义可以参考天地图在切片方案定义。 高德地图，典型切片格式地址为http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size=1&amp;scale=1&amp;style=7&amp;x={x}&amp;y={y}&amp;z={z}。其中，z为切片层级，y为切片行号，x为切片列号。 谷歌地图谷歌地图服务的切片方案和天地图的切片方案也是大致相同，其dpi、lods、origin等定义相同。区别在于，谷歌地图服务的最小层级为0，最大层级为19。第0层级的resolution为156543.033928。 国内谷歌在线地图地址，其切片地图地址格式为https://mt1.google.cn/vt/lyrs=m@226000000&amp;hl=zh-CN&amp;gl=cn&amp;x={x}&amp;y={y}&amp;z={z}&amp;s=Gali。其中，z为切片层级，y为切片行号，x为切片列号。 谷歌国际在线地图地址，其切片地图地址格式为https://mts0.google.com/vt/lyrs=m@186112443&amp;hl=en&amp;src=app&amp;x={x}&amp;y={y}&amp;z={z}&amp;s=Gali。其中，z为切片层级，y为切片行号，x为切片列号。 第0层级，切片如下 第1层级，切片如下 百度地图2023年6月19日更新：以下关于百度切片方案的说明，存在着诸多错误或是不精确的的确，此处不再进行修改。修正信息请查看百度地图切片方案这篇文章。 百度在线地图使用的坐标为百度投影米坐标，为自定义坐标格式，非标准web mercator投影坐标。百度在线地图的切片方案和上述几种在线地图的切片方案，存在着较大差异。除dpi因素和size因素一致之外，以下信息存在着区别： 百度地图切片的起点为[-3.3554432E7, 3.3554432E7]，转换成经纬度表示为[-180, 85]，可以得出百度地图切片的实际全图范围为百度经纬度[-180,-85, 180, 85]这个范围，用百度米来表示的话全图范围为[-3.3554432E7, -3.3554432E7, 3.3554432E7,3.3554432E7]。 根据1中得出的百度切图全图范围和lods的计算公式，可以得出百度在线地图服务的resolutions信息如下，进而可以计算出对应的scale信息。 12345678910111213141516171819202122[ 262144.0, 131072.26214452417, 65536.13107226208, 32768.0, 16384.0, 8192.0, 4096.0, 2048.0, 1024.0, 512.0, 256.0, 128.0, 64.0, 32.0, 16.0, 8.0, 4.0, 2.0, 1.0, 0.5]; 百度地图的最小层级为3， 最大层级为19。第3层级对应的resolution为32768.0。在第3层级中，使用8 * 8张图片来表示整个世界范围，其切片拼接之后效果如下所示(图片长宽不一致的原因为部分切片为空白图片，没有显示的原因）。 百度地图的切片的行列号计算方式为非标准形式，在根据行号、列号、切图层级计算其真实切图图片对应地址的过程中，需要进行一番转换，具体的运算过程如下所示。 12345678910111213getTileUrl: function (level, row, col) &#123; var zoom = level - 1; var offsetX = parseInt(Math.pow(2, zoom)); var offsetY = offsetX - 1; var numX = col - offsetX, numY = (-row) + offsetY; if (numX &lt; 0) &#123; numX = &#x27;M&#x27; + (-numX); &#125; if (numY &lt; 0) &#123; numY = &#x27;M&#x27; + (-numY); &#125; return &#x27;http://online1.map.bdimg.com/tile/?qt=vtile&amp;x=&#x27; + numX + &#x27;&amp;y=&#x27; + numY + &#x27;&amp;z=&#x27; + level + &#x27;&amp;styles=pl&amp;scaler=1&amp;udt=20190929&#x27;;&#125; 举例如下， 对于第3层级的行号（low）为0，列号（col）为0的切片，经过转换后，行号为3，列号为M4。对于第3层级的行号为2，列号为6的切片，转换后，行号为1，列号为2。其它的转换结果，可自行验证。 其切片地址格式为http://online1.map.bdimg.com/tile/?qt=vtile&amp;x={x}&amp;y={y}&amp;z={level}&amp;styles=pl&amp;scaler=1&amp;udt=20190929，其中level为层级，x为列号，y为行号。 ArcGIS Server 切片地图在使用ArcGIS js api来加载ArcGIS Server发布的切片地图服务的时候，往往不需要额外的关心切片地图方案的上述配置项，原因是arcgis js api来加载arcgis server切片地图服务的过程中，中间有一个步骤是自动获取和服务的元数据页面获取相关配置项，获取方式为在服务地址后拼接?f&#x3D;json参数。 额外说明以上所说的相关信息，只适用于传统的切片地图服务。近段时间，矢量切片技术使用的愈加广泛，当前主流的地图服务厂商，如高德、百度等，都已经将站点切换到了新方案地图，访问最新的服务地址如map.baidu.com等，将不会再获取传统的切片地图。 勘误 关于高德地图的dpi。经过测试，访问如下地址的切片：http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size&#x3D;1&amp;scale&#x3D;1&amp;style&#x3D;7&amp;x&#x3D;{x}&amp;y&#x3D;{y}&amp;z&#x3D;{z}，z在0-9范围时候，获取的切片的dpi经计算为2。但在访问如下地址的切片：http://webrd01.is.autonavi.com/appmaptile?lang=zh_cn&amp;size&#x3D;1&amp;scale&#x3D;1&amp;style&#x3D;8&amp;x&#x3D;{x}&amp;y&#x3D;{y}&amp;z&#x3D;{z}，z在0-9范围内，获取的切片的dpi经计算为96。关于style的含义，没有查找到相关资料，因此尚不明确此处的差异。根据经验，此处修正高德地图的切片访问地址为style&#x3D;8。","tags":["tile-map","baidu","gaode","google","tianditu"],"categories":["gis"]},{"title":"扩展dubbo官网页面宽度的chrome插件","path":"/posts/2020/0BED1D48/","content":"最近，我又一次的开始了对apache dubbo框架的学习。过去的一年里，陆陆续续的投入了一些时间在这个框架上面。无奈，工作的限制让我在日常中并不会用到这个框架，导致我对dubbo的掌握总是不太牢固。希望这一次可以在以往的基础上更进一步，对它的掌握更加彻底一些。 这几天，在浏览dubbo官方页面上的用户手册的时候，对页面的展示效果是越来越不满意。不满主要集中在，官方页面中的默认宽度实在是太小了，导致页面中的表格内容稍微多一些，表格底下就会出现一个大大的滚动条，展示效果如图所示。 滚动条的存在，导致文字浏览起来十分的不便。而这个时候，其实屏幕上还有大片的空白区域没有利用起来。通过f12查看页面源代码可以发现，页面展示区域是设置了最大宽度为1280px。 12345678.content-section &#123; max-width: 1280px; margin: 0 auto; box-sizing: border-box; padding: 40px 40px 60px; position: relative; min-height: 1100px;&#125; 如果取消了max-width属性的设置，则效果将会变为下图所示。表格中文字的展示看起来舒服了很多，很多之前需要拖动滚动条才能展示的内容，已经直接展示了出来。 现在的问题就很明确了，每次打开一个新页面之后，我们f12一下，稍作改动，问题就可以圆满解决，看上去也不是太麻烦。 但是，这样重复的动作，如果你还是像我一样觉得还是有些麻烦。那该怎么办呢？ 思考一下，今天的主角chrome插件就呼之欲出了。 对于chrome浏览器，我想所有的人都不陌生。其提供的插件机制，每个人或多或少也都有所了解。我们对chrome的插件机制就不多做介绍了，chrome的插件开发文档应该说的更加清楚，感兴趣的可以浏览以下地址：创建Chrome扩展程序。 下面就简单看一下这个功能过于简单的插件具体是如何实现的吧。 首先看插件的描述信息，即manifest.json文件。 123456789101112131415161718192021222324&#123; &quot;manifest_version&quot;: 2, &quot;author&quot;: &quot;maslke(maslke@outlook.com)&quot;, &quot;name&quot;: &quot;expander&quot;, &quot;description&quot;: &quot;expand dubbo webpage table width&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;permissions&quot;: [ &quot;tabs&quot; ], &quot;browser_action&quot;: &#123; &quot;default_icon&quot;: &quot;icons/16.png&quot;, &quot;default_title&quot;: &quot;expand it!&quot;, &quot;default_popup&quot;: &quot;expander.html&quot; &#125;, &quot;icons&quot;: &#123; &quot;16&quot;: &quot;icons/16.png&quot; &#125;, &quot;content_scripts&quot;: [&#123; &quot;matches&quot;: [&quot;http://dubbo.apache.org/zh-cn/docs/**/*.html&quot;, &quot;https://dubbo.apache.org/en-us/docs/**/*.html&quot;], &quot;js&quot;: [&quot;js/dubbo.js&quot;], &quot;css&quot;: [&quot;css/custom.css&quot;], &quot;run_at&quot;: &quot;document_end&quot; &#125;]&#125; 以上内容中，需要关注的是content_scripts节点。其中，matches节点定义了插件起作用的url地址，如上的配置表明了插件只在dubbo官方网站页面上生效。js和css分别配置了嵌入到dubbo页面中的js脚本和css样式文件。run_at表示是在页面加载完成之后再执行嵌入的脚本、插入样式文件。 在这里需要区分插件使用的脚本和嵌入到页面中的脚本。插件的dom和页面中的dom是隔离的，我们不能通过插件的脚本来直接操作页面中的dom，对页面dom的操作只能通过嵌入到页面中的脚本来执行。 本文的插件就只有两个功能，分别为扩展表格宽度和恢复，分别由两个菜单来进行触发。点击菜单之后，页面展示如下 页面的html实现如下 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Expander&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/index.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;ul class=&quot;opts&quot;&gt; &lt;li id=&quot;expand&quot;&gt;expand&lt;/li&gt; &lt;li id=&quot;reset&quot;&gt;reset&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js文件的内容也非常简单，就是给两个li元素添加上点击事件，在li元素进行点击的时候，触发特定类型的事件。前面说了，插件使用的脚本和页面中嵌入的脚本是隔离的，两者没有办法直接互相操作。那两者之间如何进行交互呢？chrome已经提供了完备的方案，可以实现上述的目的。此处我们不对chrome提供的各项方案进行详细的描述，这次选中的是sendMessage的方式。 12345678910111213(function (context) &#123; document.getElementById(&#x27;expand&#x27;).onclick = function() &#123; chrome.tabs.query(&#123; active: true, currentWindow: true &#125;, function (tabs) &#123; chrome.tabs.sendMessage(tabs[0].id, &#x27;expand&#x27;); &#125;); &#125; document.getElementById(&#x27;reset&#x27;).onclick = function() &#123; chrome.tabs.query(&#123; active: true, currentWindow: true &#125;, function (tabs) &#123; chrome.tabs.sendMessage(tabs[0].id, &#x27;reset&#x27;); &#125;); &#125;&#125;(window)); 页面中脚本使用sendMessage的方式来发送消息，在页面的嵌入脚本中通过addListener的方式来执行消息的接收。 1234567891011121314151617chrome.runtime.onMessage.addListener(function (request, sender, sendResponse) &#123; var sections = document.getElementsByClassName(&#x27;content-section&#x27;); if (request === &#x27;expand&#x27;) &#123; if (sections.length !== 0) &#123; var section = sections[0]; section.classList.add(&#x27;content-section-custom&#x27;); &#125; &#125;; if (request === &#x27;reset&#x27;) &#123; if (sections.length !== 0) &#123; var section = sections[0]; section.classList.remove(&#x27;content-section-custom&#x27;); &#125; &#125;; sendResponse(&#x27;done&#x27;); return true;&#125;); 以上即是全部的实现逻辑了。虽然功能简单，但一个chrome插件的相关基本元素都已经具备了：描述文件、弹出页面popup.html、插件逻辑、消息通信。正所谓，麻雀虽小，五脏俱全。有了以上的相关知识，后续如果有更加复杂的需求，想必也可以在此基础上扩展实现。 编写完成之后，在插件的管理页面，选择Load unpacked按钮，即可将插件添加到chrome中去了。由于这个插件过于简单，就没必要上传到chrome商店了。自己用着开心就好。 我将所有的代码上传到了github上，地址为expand-dubbo-table。感兴趣的可以尝试一下。","tags":["dubbo","chrome-extension"],"categories":["chrome","javascript"]},{"title":"如何解码arcgis compressed geometry","path":"/posts/2020/385BA9A7/","content":"简介arcgis compressed geometry 是一种编码过的线图形格式。线图形经过编码后，体积变小，可以高效的在网络中进行传输。 compressed geometry常用于arcgis网络数据集的路径查询和导航相关接口的返回结果中。 compressed geometry的格式为形如“+0+1+3+1+emjd+3j07m+3+0+0+1-3-1|+9og+0+lv4+0+lv4|+5rg+uq+r9+au+168”或是“+1m91-6fkfr+202tp+k+f+7+3+34+2d”的字符串。 组成线图形的点，其坐标格式除支持x和y坐标之外，同时也支持z和m坐标。 如何解码对于compressed geometry字符串，其解码方式如下。 字符串起始的“+0”表示格式为arcgis compressed geometry的新版本格式。如起始字符串不是“+0”的话，则表示采用的格式为旧版本，直接跳到步骤4即可。 紧接着的“+1”，为版本号，当前阶段只能为1。 再后面的“+3”，标识了点的坐标格式。0表示，只有x和y坐标，1表示具有x、y、z坐标，2表示具有x、y、m坐标，3表示具有x、y、z、m坐标。 去除以上相关的元数据信息之外，剩余的字符串为“+1+emjd+3j07m+3+0+0+1-3-1|+9og+0+lv4+0+lv4|+5rg+uq+r9+au+168”。 根据步骤3中的说明，此图形中包含有x、y、z、m坐标。其中xy坐标在一起进行存储，z坐标和m坐标独立存储，xy坐标、z坐标、m坐标之间使用“|”进行分隔。根据此规则对上述的字符串进行拆分，则xy坐标串为“+1+emjd+3j07m+3+0+0+1-3-1”，z坐标串为“+9og+0+lv4+0+lv4”，m坐标串为“+5rg+uq+r9+au+168”。 对于xy坐标，其格式为”+factor+startX+startY+differX1+differY1+differX2+differY2…”。其中，factor为一个因子，存储的真实坐标为x &#x2F; factor或是y &#x2F; factor。其中，第一个点的x坐标为startX，后续点与前面点的差值为differX。比如，第三个点的真实坐标为(startX+differX1+differX2) &#x2F; factor。这里需要注意两点： factor、startX、startY等数字在编码字符串中是使用的32进制进行存储的，解码的时候需要转换成10进制表达形式。 startX、startY、differX、differY等可以是负值。如果是正值，在编码字符串中表现为“+”，否则表现为“-”。 对于z和m坐标，解码方式类似。与xy坐标的差异在于，z和m是独立进行存储的，因此只存在一个start和一个differ，其余部分完全一致。 代码说明有了以上对编码方式的说明之后，就可以进行编码来对坐标进行解码了。 123456789101112131415161718192021222324252627282930public static Line decode(String geometry) &#123; String[] parts = geometry.split(&quot;\\\\|&quot;); String first = parts[0]; if (first.startsWith(&quot;+0&quot;)) &#123; int flag = Integer.parseInt(first.substring(5, 6)); int version = Integer.parseInt(first.substring(3, 4)); if (version != 1) &#123; throw new IllegalArgumentException(&quot;Compressed geometry: Unexpected version.&quot;); &#125; if (flag &gt; 3) &#123; throw new IllegalArgumentException(&quot;Compressed geometry: Invalid flags.&quot;); &#125; first = first.substring(6); Line line = decodeXy(first); if (flag == 0) &#123; return line; &#125; if ((flag &amp; 1) == 1) &#123; BiConsumer&lt;Point, Double&gt; consumer = Point::setZ; decode(line, partas[1], consumer); &#125; if ((flag &amp; 2) == 2) &#123; BiConsumer&lt;Point, Double&gt; consumer = Point::setM; decode(line, parts[parts.length - 1], consumer); &#125; return line; &#125; else &#123; return decodeXy(first); &#125; &#125; 以上的处理代码中，首先判定字符串的起始两个字符。如果为“+0”的话，则表示了需要解码的compressed geometry为新格式，可以包含Z或是M坐标，否则为老格式，只需要进行x和y的解码即可。 除此之外，还进行了version和flag的判断。在值不合法的情况下，直接抛出IllegalArgumentException异常。 对xy坐标的解码逻辑如下。 1234567891011121314151617181920212223242526272829303132private static Line decodeXy(String part) &#123; List&lt;String&gt; xys = extract(part); int factor = Integer.parseInt(xys.get(0), 32); int differenceX = 0; int differenceY = 0; Point[] points = new Point[(xys.size() - 1) / 2]; int inx = 0; for (int i = 1; i &lt; xys.size(); i = i + 2) &#123; int x = Integer.parseInt(xys.get(i), 32); int y = Integer.parseInt(xys.get(i + 1), 32); differenceX += x; differenceY += y; points[inx++] = new Point(differenceX * 1.0 / factor, differenceY * 1.0 / factor); &#125; return new Line(points); &#125; private static List&lt;String&gt; extract(String part) &#123; Matcher matcher = pattern.matcher(part); List&lt;String&gt; xys = new ArrayList&lt;&gt;(); while (matcher.find()) &#123; String p1 = matcher.group(1); String p2 = matcher.group(2); if (&quot;-&quot;.equals(p1)) &#123; xys.add(&quot;-&quot; + p2); &#125; else &#123; xys.add(p2); &#125; &#125; return xys; &#125; 在以上逻辑中，使用了正则表达式来进行字符串相关部分的提取。 1private static final Pattern pattern = Pattern.compile(&quot;([+-])([^+-]+)&quot;); 需要关注的是，在模式匹配过程中，如果匹配到的是“-”字符，则表示当前的数字是负值。 12345if (&quot;-&quot;.equals(p1)) &#123; xys.add(&quot;-&quot; + p2); &#125; else &#123; xys.add(p2); &#125; 对于z坐标或是m坐标的处理逻辑大致相同。 1234567891011private static void decode(Line line, String part, BiConsumer&lt;Point, Double&gt; consumer) &#123; List&lt;String&gt; items = extract(part); int factor = Integer.parseInt(items.get(0), 32); int difference = 0; int inx = 0; for (int i = 1; i &lt; items.size(); i++) &#123; int value = Integer.parseInt(items.get(i), 32); difference += value; consumer.accept(line.getPoints()[inx++], difference * 1.0 / factor); &#125; &#125;","tags":["arcgis"],"categories":["gis"]},{"path":"/page/sudoku.html","content":"Sodoku .fix { font-size: 25px; border: none; background-color: transparent; WIDTH: 30px; HEIGHT: 30px; LINE-HEIGHT: 28px; TEXT-ALIGN: center; margin: 0px; COLOR: #000000; FONT-FAMILY: Verdana; } .big { font-size: 25px; border: none; background-color: transparent; WIDTH: 30px; HEIGHT: 30px; LINE-HEIGHT: 28px; TEXT-ALIGN: center; margin: 0px; COLOR: #0000FF; FONT-FAMILY: Verdana; } td.xx { border-right: #999 1px solid; border-top: #999 1px solid; text-align: center; LINE-height: 30px; } td.rr { border-right: #443 2px solid; border-top: #999 1px solid; text-align: center; LINE-height: 30px; } td.bb { border-right: #999 1px solid; border-top: #999 1px solid; border-bottom: #443 2px solid; text-align: center; LINE-height: 30px; } td.br { border-right: #443 2px solid; border-top: #999 1px solid; border-bottom: #443 2px solid; text-align: center; LINE-height: 30px; } .sd { table-layout: fixed; border: #443 3px solid; margin: 0 20px; background-color: #fff; vertical-align: middle; border-collapse: collapse; text-align: center; } #container { margin: 0 auto; border-spacing: 1px; border-collapse: collapse; } #operator { margin: 5px auto 5px auto; } #operator input[type=\"button\"] { background-color:rgb(240, 240, 240); height: 30px; } // try a random order when solving the problem const numbers = []; const cache = new Set(); while (numbers.length < 9) { const v = Math.floor(Math.random() * 9 + 1); if (!cache.has(v)) { cache.add(v); numbers.push(v); } } function copy(values) { const copyed = []; for (let inx = 0; inx < values.length; inx += 1) { copyed.push([...values[inx]]); } return copyed; } function clearBoard() { for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { document.querySelector(`#s${i}${j}`).value = ''; } } } // generate a valid board function generate() { clearBoard(); const board = []; for (let inx = 0; inx < 9; inx += 1) { board.push(new Array(9).fill(0)); } solve(board, 0); const orders = []; const visited = new Set(); while (orders.length < 81) { const v = Math.floor(Math.random() * 81); if (!visited.has(v)) { visited.add(v); orders.push(v); } } const maxEmpty = 45; let count = 0; for (let inx = 0; inx < 81; inx += 1) { if (count === maxEmpty + 1) { break; } const v = orders[inx]; const i = Math.floor(v / 9); const j = v % 9; const original = board[i][j]; board[i][j] = 0; if (solve(copy(board), 0)) { count += 1; } else { board[i][j] = original; } } printToPage(board); } function printToPage(values) { for (let i = 0; i < 9; i++) { for (let j = 0; j < 9; j++) { if (values[i][j] !== 0) { document.querySelector(`#s${i}${j}`).value = values[i][j]; } } } } function valid(values, x, y) { var number = values[x][y]; for (let i = 0; i < 9; i++) { if (values[i][y] === number && i !== x) { return false; } if (values[x][i] === number && i !== y) { return false; } } var row = parseInt(x / 3) * 3; var col = parseInt(y / 3) * 3; for (let i = row; i < row + 3; i++) { for (let j = col; j < col + 3; j++) { if (i === x && j === y) { continue; } if (values[i][j] === number) { return false; } } } return true; } function solve(values, inx) { if (inx === 81) { return true; } const i = Math.floor(inx / 9); const j = inx % 9; if (values[i][j] !== 0) { return solve(values, inx + 1); } else { for (let k of numbers) { values[i][j] = k; if (valid(values, i, j) && solve(values, inx + 1)) { return true; } values[i][j] = 0; } return false; } } /* * collect values from the input controls */ function collect() { const values = []; for (let inx = 0; inx < 9; inx += 1) { values.push(new Array(9).fill(0)); } var inputs = document.querySelectorAll('#container input'); var id, input, value; var row, col; for (let i = 0; i < inputs.length; i++) { input = inputs[i]; if (input.type === 'button') { continue; } id = input.id; value = input.value; row = id.substring(1, 2); col = id.substring(2); if (value === '' || value === 0) { values[row][col] = 0; input.className = 'big'; } else { values[row][col] = parseInt(value); } } return values; } /* * begin to solve the problem */ function beginSolve() { const values = collect(); const success = solve(values, 0); if (success) { printToPage(values); } else { alert('are you serious?'); } } const { clientWidth } = document.documentElement; const width = Math.min(clientWidth * 0.9, 750); const operator = document.querySelector('#operator'); operator.style.width = `${width}px`; const container = document.querySelector('#container'); container.style.width = `${width}px`; container.style.height = `${width}px`;"}]